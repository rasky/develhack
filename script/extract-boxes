#!/usr/bin/env python2.7
# -*- coding: utf-8 -*-

from __future__ import division, print_function

import argparse
import collections
import datetime
import os
import os.path
import struct
import sys

from PIL import Image

#
# Types
#

FRAME_SIZE = 128

Box = collections.namedtuple('Box', ['name', 'color', 'x', 'y', 'w', 'h'])


class BoxColor:
    Blue, Red, White = range(3)

#
# C source templates
#

TEMPLATE_SOURCE = '''
/*
 * Generated by: {args}
 * On: {date}
 */

#include "hitbox.h"

const HitboxDesc HITBOXES[{count}] = {{
{hitboxes}
}};
'''

TEMPLATE_HITBOX = '    {{ "{name}", {{ {x}, {y}, {w}, {red}, {h}, {white} }} }},\n'

#
# Source
#


def main():
    args = parse_args()

    if not os.path.isdir(args.source):
        print('%s: must be a directory.' % args.source)
        sys.exit(1)

    boxes = []
    for png in [p for p in os.listdir(args.source) if p.endswith('.png')]:
        boxes += extract_boxes(os.path.join(args.source, png), file_name_to_color(png))

    with open(args.output, 'w') as f:
        hitboxes = ""

        for box in sorted(boxes, key=lambda x: x.name):
            red = 1 if box.color == BoxColor.Red else 0
            white = 1 if box.color == BoxColor.White else 0
            hitboxes += TEMPLATE_HITBOX.format(
                name=box.name[:-2], x=box.x, y=box.y, w=box.w, red=red, h=box.h, white=white)

        f.write(TEMPLATE_SOURCE.format(
            args=' '.join(sys.argv), date=datetime.datetime.now(), count=len(boxes), hitboxes=hitboxes))


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument('source', help='Source file')
    parser.add_argument('-o', '--output', help='Destination file', required=True)

    return parser.parse_args()


def file_name_to_color(path):
    if path.endswith('_b.png'):
        return BoxColor.Blue
    elif path.endswith('_r.png'):
        return BoxColor.Red
    elif path.endswith('_w.png'):
        return BoxColor.White
    else:
        raise ValueError('Unknown box type')


def extract_boxes(path, color):
    # Box name is the file's basename, without the extension
    name = os.path.splitext(os.path.basename(path))[0]

    # Load image
    im = Image.open(path)
    px = im.load()
    width, height = im.size

    assert height % FRAME_SIZE == 0
    assert width == FRAME_SIZE

    # Determine background and boxes color
    bg = px[0, 0]

    # Find bounding boxes
    boxes = []

    def get_bounding_box(start_x, start_y):
        box_x, box_y = start_x, start_y

        for x in xrange(start_x, width):
            if px[x, start_y] == bg:
                box_w = x - box_x - 1
                break

        for y in xrange(start_y, height):
            if px[start_x, y] == bg:
                box_h = y - box_y - 1
                break

        for y in xrange(box_y, box_y + box_h + 1):
            for x in xrange(box_x, box_x + box_w + 1):
                px[x, y] = bg

        # NOTE: Frames are stacked vertically, no need to take modulo of 'x' coordinates.
        return Box(name, color, box_x, box_y % FRAME_SIZE, box_w, box_h)

    for y in xrange(0, height):
        for x in xrange(0, width):
            if px[x, y] != bg:
                boxes.append(get_bounding_box(x, y))

    return boxes


if __name__ == '__main__':
    main()
