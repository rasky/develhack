#!/usr/bin/env python2.7
# -*- coding: utf-8 -*-

from __future__ import division, print_function

import argparse
import collections
import datetime
import os
import os.path
import struct
import sys

from PIL import Image

FRAME_SIZE = 128

Box = collections.namedtuple('Box', ['x', 'y', 'w', 'h'])


class BoxColor:
    Blue, Red, White = range(3)


def main():
    args = parse_args()

    if not os.path.isdir(args.source):
        print('%s: must be a directory.' % args.source)
        sys.exit(1)

    serialize(get_desc(args.source), args.output)


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument('source', help='Source file')
    parser.add_argument('-o', '--output', help='Destination file', required=True)

    return parser.parse_args()


def serialize(desc, path):
    with open(path, 'w') as f:
        write = lambda x: f.write(x)
        writeln = lambda x: f.write(x + '\n')

        writeln('/*')
        writeln(' * Generated by: %s' % ' '.join(sys.argv))
        writeln(' * On: %s' % datetime.datetime.now())
        writeln(' */')
        writeln('')
        writeln('#include "hitbox.h"')
        writeln('')
        writeln('const HitboxDesc Hitboxes[MAX_HITBOXES] = {')

        for name in sorted(desc.keys()):
            def render(box):
                if box:
                    return '{ %s, %s, %s, %s }, ' % (box.x, box.y, box.w, box.h)
                else:
                    return '{ 0, 0, 0, 0 }, '

            writeln('    { "%s", {' % name)

            # Header
            write('        /*        ')
            write('White'.ljust(len(render(desc[name][0][0]))))
            write('Blue'.ljust(len(render(desc[name][0][1]))))
            write('Red')
            writeln(' */')

            for i, frame in enumerate(desc[name], start=1):
                write('        /* %s */ { ' % i)

                for box in frame:
                    write(render(box))
                    # if box:
                    #     write('{ %s, %s, %s, %s }, ' % (box.x, box.y, box.w, box.h))
                    # else:
                    #     write('{ 0, 0, 0, 0 }, ')

                writeln('},')

            writeln('    }},')

        writeln('};')


def get_desc(path):
    desc = {}

    animations = {p[:-6] for p in os.listdir(path) if p.endswith('.png')}
    for animation in sorted(animations):
        if not animation in desc:
            desc[animation] = []

        # Assuming white frame is always available
        white = extract_boxes(os.path.join(path, animation + '_w.png'))
        blue = extract_boxes(os.path.join(path, animation + '_b.png'))
        red = extract_boxes(os.path.join(path, animation + '_r.png'))

        if blue:
            assert len(blue) == len(white)

        if red:
            assert len(red) == len(red)

        for frame in range(len(white)):
            desc[animation].append([white[0], get_or_none(blue, frame), get_or_none(red, frame)])

    return desc


def extract_boxes(path):
    if not os.path.isfile(path):
        return []

    # Box name is the file's basename, without the extension
    name = os.path.splitext(os.path.basename(path))[0]

    # Load image
    im = Image.open(path)
    px = im.load()
    width, height = im.size

    assert height % FRAME_SIZE == 0
    assert width == FRAME_SIZE

    # Determine background and boxes color
    bg = px[0, 0]

    # Find bounding boxes
    boxes = []

    def get_bounding_box(start_x, start_y):
        box_x, box_y = start_x, start_y

        for x in xrange(start_x, width):
            if px[x, start_y] == bg:
                box_w = x - box_x - 1
                break

        for y in xrange(start_y, height):
            if px[start_x, y] == bg:
                box_h = y - box_y - 1
                break

        for y in xrange(box_y, box_y + box_h + 1):
            for x in xrange(box_x, box_x + box_w + 1):
                px[x, y] = bg

        # NOTE: Frames are stacked vertically, no need to take modulo of 'x' coordinates.
        return Box(box_x, box_y % FRAME_SIZE, box_w, box_h)

    for frame in range(1, int(height / FRAME_SIZE) + 1):
        box_found = False

        for y in xrange(0, frame * FRAME_SIZE):
            for x in xrange(0, width):
                if px[x, y] != bg:
                    boxes.append(get_bounding_box(x, y))
                    box_found = True

        if not box_found:
            boxes.append(None)

    return boxes


def get_or_none(iterable, i):
    if i < len(iterable):
        return iterable[i]
    else:
        return None


if __name__ == '__main__':
    main()
